{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix karigar mapping matching by scanning all sheets and applying consistent design-code normalization",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Parse karigar mapping tables from priority sheets first, then scan all remaining sheets for required columns regardless of sheet name.",
      "acceptanceCriteria": [
        "Uploading a mapping workbook where the mapping table exists on a non-priority sheet name (e.g., \"Sheet1\") successfully loads mappings.",
        "Uploading a mapping workbook that contains sheets named \"1\"/\"2\"/\"3\" but has the mapping table on a different sheet still loads mappings from that other sheet.",
        "When multiple sheets contain valid mappings for the same Design code, entries from sheets are applied in priority order: \"1\" then \"3\" then \"2\" then the remaining sheets in workbook order (or a deterministic documented order).",
        "The parser continues to treat columns case-insensitively and via header aliases, and continues to support optional NAME (generic name) and required KARIGAR."
      ],
      "file_operations": [
        {
          "path": "frontend/src/features/daily-orders/excel/parseKarigarMapping.ts",
          "operation": "modify",
          "description": "Update Excel workbook parsing to always: (1) attempt sheets \"1\"→\"3\"→\"2\" when present, and (2) additionally scan all remaining sheets (any name) and include any sheet containing the required Design + Karigar columns (with optional Name). Ensure scan order after priority sheets is deterministic (documented in code comments), and keep existing case-insensitive header alias behavior and design-code normalization via normalizeDesignCode."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Apply mapping lookups using mappings from all parsed sheet names, preserving priority-sheet preference while falling back to other sheets.",
      "acceptanceCriteria": [
        "If a mapping blob contains only non-priority sheet names, Order List still enriches orders (Generic Name and Karigar) when Design codes match.",
        "If a mapping blob contains both priority and non-priority sheets, Order List enrichment prefers matches from priority sheets but still matches against non-priority sheets when a Design is not present in priority sheets.",
        "The Order List “Mapping Status” section no longer shows “mapping loaded but no orders match” for the user’s provided scenario where the mapping table contains matching design codes (assuming normalization rules make them equivalent)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/features/order-list/useKarigarMappingLookup.ts",
          "operation": "modify",
          "description": "Expand lookup construction to read mappings from all sheets present in the decoded mapping blob, applying entries in this order: \"1\" then \"3\" then \"2\", then all remaining sheet names in a deterministic order. Preserve existing behavior where earlier sheets win for duplicate normalized design keys, and keep canonical normalization via normalizeDesignCode for every entry."
        },
        {
          "path": "frontend/src/features/karigar-mapping/getMappingSheetReadOrder.ts",
          "operation": "create",
          "description": "Add a small helper that computes the deterministic sheet read order given available sheet names: priority sheets (\"1\",\"3\",\"2\") first (if present), then remaining sheets in a documented deterministic order (e.g., workbook/decoded key order fallback to localeCompare sorting). This helper should be used by mapping lookup logic to ensure consistent priority + fallback behavior."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Use a single shared canonical normalizeDesignCode for both ingestion and matching, and keep clear diagnostics when there are zero matches.",
      "acceptanceCriteria": [
        "Order designs and mapping designs are both normalized using the same normalizeDesignCode function before lookup.",
        "When there are 0 matches but a mapping is loaded, the UI shows debug samples of normalized order keys and normalized mapping keys (no crash).",
        "Re-uploading a mapping workbook after this change immediately affects matching without requiring backend schema changes or manual data migration (existing stored blobs remain decodable and usable)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/features/daily-orders/excel/parseKarigarMapping.ts",
          "operation": "modify",
          "description": "Ensure mapping ingestion continues to compute and store designNormalized using the shared normalizeDesignCode function for every parsed row, so the same canonical rules are used at ingest time."
        },
        {
          "path": "frontend/src/features/order-list/OrderListTab.tsx",
          "operation": "modify",
          "description": "Refine/retain the zero-match diagnostics to explicitly surface sample normalized order keys and sample normalized mapping keys when mapping is loaded but matchedOrders is 0. Ensure this remains resilient (no crashes) and continues to use normalizeDesignCode for order-side normalization."
        },
        {
          "path": "frontend/src/features/karigar-mapping/karigarMappingBlobCodec.ts",
          "operation": "modify",
          "description": "Keep backward-compatible decoding behavior that recomputes designNormalized from the stored design field using normalizeDesignCode so older stored blobs immediately benefit from updated normalization and matching without backend changes."
        }
      ]
    }
  ]
}